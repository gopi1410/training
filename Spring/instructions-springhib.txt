from http://github.com/maruthirj/training
Download: db-derby-10.11.1.1-bin.zip
Download: mydb.zip
Download tomcat:
http://107.108.53.191:8080/WebProj/tools/apache-tomcat-8.0.23-windows-x86.zip
Download eclipse:
http://107.108.206.119:8080/Training/eclipse.zip

-----------------------------------------
Create a new maven project in eclipse
Download pom.xml from github (Use the "raw" button to download)
Copy the <dependencies> section from the shared pom.xml into the pom.xml in your
																			project
Once you save the pom.xml all dependencies will be downloaded.
If you see errors on pom.xml, 
right click project -> maven -> update project -> force update -> ok

Download application-context.xml, User.java from github
Create two classes UserManager and UserDaoImpl and one interface UserDao
Setup setter methods on UserManager to refer to UserDao
Configure the xml
<bean id="userManager" class="com.mydomain.biz.UserManager">
	<property name="dao" ref="userDao"></property>    
</bean>
<bean id="userDao" class="com.mydomain.dao.UserDaoImpl">
</bean>


This code goes into a new class called SpringTester (in main method)
ApplicationContext context = new ClassPathXmlApplicationContext
(new String[] {"application-context.xml"});
UserManager mgr = (UserManager)context.getBean("userManager");
List<User> users = mgr.getAllUsers();
System.out.println(users);

public class UserManager {

	private UserDao dao;

	public UserDao getDao() {
		return dao;
	}
	public void setDao(UserDao dao) {
		this.dao = dao;
	}
	public List<User> getAllUsers() {
		return dao.getAllUsers();
	}
}

--------------------------------------------
Proxy
--------------------------------------------
package com.mydomain;

import java.lang.reflect.Method;
import java.rmi.RemoteException;

public class ProxyImpl implements java.lang.reflect.InvocationHandler {

	private Object obj;

	public static Object newInstance(Object obj) {
		return java.lang.reflect.Proxy.newProxyInstance(obj.getClass()
				.getClassLoader(), obj.getClass().getInterfaces(),
				new ProxyImpl(obj));
	}

	private ProxyImpl(Object obj) {
		this.obj = obj;
	}

	public Object invoke(Object proxy, Method m, Object[] args)
			throws Throwable {
		Object result;
		try {
			//do something before
			System.out.println("Actions before invoke of: "+m.getName());
			System.out.println(this);
			result = m.invoke(obj, args);
			System.out.println("Actions after method invoke...");
			//do something after
		} catch (Exception e) {
			throw new RuntimeException("unexpected invocation exception: "
					+ e.getMessage());
		}
		return result;
	}

	public static void main(String[] args) throws RemoteException {
		UserDaoImpl target = new UserDaoImpl();
		UserDao proxy = (UserDao)ProxyImpl.newInstance(target);
		System.out.println(proxy.getClass().getName());
		List<User> users = proxy.getAllUsers();
		System.out.println("Users: "+users);
	}
}
-----------------------------------
Steps to start database:

open windows command prompt
cd c:\whereeverYouUnzippedDerby\db-derby-10.11.1.1-bin\bin
set DERBY_HOME=..\
setNetworkServerCP
startNetworkServer

Replace the DAO implementation with the one provided on share
Edit the connection information to look like this:
(NOTICE THE SINGLE SLASH AFTER 1527)
jdbc:derby://localhost:1527/C:/whereever/mydb/mydb

Test it and you should see actual user objects retrieved from the DB

Securing UserDAOImpl
-------------------------------------------
Create an interface:
public interface AuthEnabler {
	public Object secureInvoke(Method m, String user, String password, Object... args);
}

Copy the ProxyImpl class you have and create a new class AuthProxyImpl
In the newInstance method, use code like this to get a list of interfaces:
List<Class> interfaces = new ArrayList(Arrays.asList(obj.getClass().getInterfaces()));
interfaces.add(AuthEnabler.class);
Class[] classArr = interfaces.toArray(new Class[1]);

In the invoke method, we do authentication like this:
if(m.getName().equals("secureInvoke")){
	//Perform auth and call the target method
	Method targetMethod = (Method)args[0];
	String user = (String)args[1];
	String pass = (String)args[2];
	if(user.equals("admin") && pass.equals("admin123")){
		Object[] methodArgs = Arrays.copyOfRange(args, 3, args.length-1);
		return targetMethod.invoke(obj, methodArgs);	
	}else{
		throw new Exception("Authentication info denied");
	}
}else{
	//Direct method invocation - prevent it
	throw new Exception("Authentication info not provided");
}

Our client code will now be like this:
UserDaoImpl daoImpl = new UserDaoImpl();
UserDao secureDao = (UserDao)AuthProxyImpl.newInstance(daoImpl);
secureDao.getAllUser();//Will throw an exception


Method getAllUsers = UserDao.class.getMethod("getAllUsers");
AuthEnabler ae = (AuthEnabler)AuthProxyImpl.newInstance(daoImpl);
System.out.println(ae.secureInvoke(getAllUsers,"admin","admin123"));
--------------------
Copy the ProxyImpl class and create a new class called ClientProxyImpl
In the newInstance method, make a check to ensure we are proxying the authproxy
public static Object newInstance(Object obj) {
	if(!(obj instanceof AuthEnabler)){
		throw new IllegalArgumentException("This class can only proxy Auth Enabled classes");
	}
	return java.lang.reflect.Proxy.newProxyInstance(obj.getClass()
				.getClassLoader(), obj.getClass().getInterfaces(),
				new ProxyImpl(obj));
}

In the invoke method, make sure we are only calling target methods:
if(m.getName().equals("secureInvoke")){
	//This should never be called directly
	throw new IllegalStateException("Secure invoke should not be called on the client proxy directly. Call the target method");
}else{
	//Grab auth info and call the secureInvoke method on the target
	String user = "admin";
	String pass = "admin123";
	return ((AuthEnabler)obj).secureInvoke(m, user, pass, args);
}

Client:
-------
UserDaoImpl daoImpl = new UserDaoImpl();
UserDao secureDao = (UserDao)AuthProxyImpl.newInstance(daoImpl);
UserDao clientDao = (UserDao)ClientProxyImpl.newInstance(secureDao);
System.out.println(clientDao.getAllUsers());

Using Factory Beans in spring
------------------------------
Create an AuthProxyFactory class
public class AuthProxyFactory implements FactoryBean {
	//Secure bean that needs proxying to pass the security info
	Object beanToSecure;
	public Object getBeanToSecure() {
		return beanToSecure;
	}
	public void setBeanToSecure(Object beanToSecure) {
		this.beanToSecure = beanToSecure;
	}
	public Object getObject() throws Exception {
		return AuthProxyImpl.newInstance(beanToSecure);
	}
	public Class getObjectType() {
		return null;
	}
	public boolean isSingleton() {
		return true;
	}
}

Create a ClientProxyFactory class
public class ClientProxyFactory implements FactoryBean {
	//Secure bean that needs proxying to pass the security info
	Object secureBean;
	public Object getSecureBean() {
		return secureBean;
	}
	public void setSecureBean(Object secureBean) {
		this.secureBean = secureBean;
	}
	public Object getObject() throws Exception {
		return ClientProxyImpl.newInstance(secureBean);
	}
	public Class getObjectType() {
		return null;
	}
	public boolean isSingleton() {
		return true;
	}
}

In application-context.xml define this configuration
<!-- Secure Bean Setup -->
	<bean name="dao" class="com.mydomain.dao.UserDaoImpl"></bean>
	<bean name="secureDao" class="com.mydomain.security.AuthProxyFactory">
		<property name="beanToSecure" ref="dao"></property>
	</bean>
	
	<bean id="authenticatedDao" name="authenticatedDao" 		
					class="com.mydomain.security.ClientProxyFactory">
		<property name="secureBean" ref="secureDao"></property>
	</bean>
	
In main method:

UserDao authDao = (UserDao)context.getBean("authenticatedDao");
System.out.println(authDao.getAllUsers());






















